<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小程序获取用户头像</title>
      <link href="/2023/07/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%A4%B4%E5%83%8F/"/>
      <url>/2023/07/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%A4%B4%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取头像"><a href="#1-获取头像" class="headerlink" title="1.获取头像"></a>1.获取头像</h2><p>需要用到 <code>button</code> 组件，设置 <code>button</code> 的属性 <code>open-type</code> 值为 <code>chooseAvatar</code>，监听 <code>button</code> 的 <code>chooseavatar</code> 事件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  open-type=<span class="string">&quot;chooseAvatar&quot;</span></span><br><span class="line">  <span class="attr">bind</span>:chooseavatar=<span class="string">&quot;getUserAvatar&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">....</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户头像</span></span><br><span class="line"><span class="title function_">getUserAvatar</span>(<span class="params">ev</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取头像对应的地址</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ev.<span class="property">detail</span>.<span class="property">avatarUrl</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="2-获取用户名"><a href="#2-获取用户名" class="headerlink" title="2.获取用户名"></a>2.获取用户名</h2><p>需要用到 <code>input</code> 组件，设置 <code>input</code> 的 <code>type</code> 属性值为 <code>nickname</code>，监听 <code>input</code> 组件的 <code>input</code> 、<code>blur</code> 、<code>change</code> 等事件获取表单中的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">&quot;nickname&quot;</span></span><br><span class="line">  <span class="attr">bind</span>:change=<span class="string">&quot;getUserNickName&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">getUserNickName</span>(<span class="params">ev</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取用户设置的昵称</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ev.<span class="property">detail</span>.<span class="property">value</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小程序中提供的常用的api</title>
      <link href="/2023/07/03/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84api/"/>
      <url>/2023/07/03/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84api/</url>
      
        <content type="html"><![CDATA[<h2 id="1-路由跳转api"><a href="#1-路由跳转api" class="headerlink" title="1.路由跳转api"></a>1.<strong>路由跳转api</strong></h2><p>wx.switchTab  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面<br>wx.reLaunch  关闭所有页面，打开到应用内的某个页面<br>wx.redirectTo 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。<br>wx.navigateTo 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。<br>wx.navigateBack 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。</p><h2 id="2-页面交互"><a href="#2-页面交互" class="headerlink" title="2.页面交互"></a>2.<strong>页面交互</strong></h2><p>wx.showToast 显示消息提示框<br>wx.showModal 显示模态对话框<br>wx.showLoading  显示 loading 提示框。<br>wx.showActionSheet  显示操作菜单<br>wx.hideToast  隐藏消息提示框<br>wx.hideLoading  隐藏 loading 提示框</p><h2 id="3-获取用户信息"><a href="#3-获取用户信息" class="headerlink" title="3.获取用户信息"></a>3.<strong>获取用户信息</strong></h2><p>wx.getUserProfile</p><h2 id="4-请求数据"><a href="#4-请求数据" class="headerlink" title="4.请求数据"></a>4.<strong>请求数据</strong></h2><p>wx.request  可通过RequestTask.abort() 取消发送请求</p><h2 id="5-下载文件-x2F-上传文件"><a href="#5-下载文件-x2F-上传文件" class="headerlink" title="5.下载文件&#x2F;上传文件"></a>5.<strong>下载文件</strong>&#x2F;<strong>上传文件</strong></h2><p>wx.downloadFile 下载</p><p>wx.uploadFile 上传</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决跨域问题</title>
      <link href="/2023/06/12/%E5%AF%B9%E4%BA%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/06/12/%E5%AF%B9%E4%BA%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>因为浏览器的同源策略，当浏览器向不同源的服务器发起请求时，就会产生跨域问题。解决跨域问题的方法有以下几种：</p><ol><li>jsonp： 通过 <script> 标签加载外部资源，这种方法只支持get请求，已经很少用了。</li><li>cors  直接请求服务器</li><li>代理服务器 ，项目上线通过nginx代理：  配置代理走代理</li></ol><h6 id="跨域的情况如何处理"><a href="#跨域的情况如何处理" class="headerlink" title="跨域的情况如何处理:"></a>跨域的情况如何处理:</h6><ol><li><p>直接请求服务器 => cors 解决跨域</p><ul><li>baseURL: process.env.VUE_APP_BASE_API</li><li>VUE_APP_BASE_API = 完整服务器地址</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js发请求:</span><br><span class="line">- request.<span class="title function_">post</span>(<span class="string">&#x27;/sys/login&#x27;</span>, data)</span><br><span class="line">实际请求会拼接基地址: </span><br><span class="line">- 完整服务器地址 + <span class="regexp">/sys/</span>login</span><br></pre></td></tr></table></figure></li><li><p>请求自身服务器 => 代理 解决的跨域<br>(1) 配置vue.config.js<br> proxy: {<br>   // 以 /api 开头的路径请求, 认为需要走代理<br>   // 需要这么发请求:   <a href="http://localhost:8888/api/sys/login">http://localhost:8888/api/sys/login</a><br>   // 代理后:          <a href="http://ihrm-java.itheima.net/api/sys/login">http://ihrm-java.itheima.net/api/sys/login</a><br>   // 将本机地址, 会替换成代理的地址, 进行请求<br>   '/api': {<br>     target: '<a href="http://ihrm-java.itheima.net/">http://ihrm-java.itheima.net</a>'<br>   }<br> }<br>希望代理能生效, 两个条件: 请求本机地址(可省略) + /api路径标识<br>(2) 配置基地址</p><ul><li><p>baseURL: process.env.VUE_APP_BASE_API</p></li><li><p>VUE_APP_BASE_API = "/api"</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发请求正常发</span><br><span class="line">- request.<span class="title function_">post</span>(<span class="string">&#x27;/sys/login&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">实际的请求会拼接上基地址</span><br><span class="line">- <span class="regexp">/api/</span>sys/<span class="function"><span class="params">login</span>  =&gt;</span> 本机地址 + <span class="regexp">/api/</span>sys/<span class="function"><span class="params">login</span> =&gt;</span> 走代理了</span><br><span class="line"></span><br><span class="line">走代理会将本机地址进行替换</span><br><span class="line">- 实际请求地址 =&gt; 代理地址 + <span class="regexp">/api/</span>sys/login</span><br><span class="line"></span><br><span class="line">小<span class="attr">tip</span>: 如果实际请求地址, 不需要 /api 标识, 配置pathRewrite进行重写</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SPA的理解</title>
      <link href="/2023/06/04/SPA%E5%92%8CMPA/"/>
      <url>/2023/06/04/SPA%E5%92%8CMPA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、说一说对SPA的理解-和MPA的区别"><a href="#一、说一说对SPA的理解-和MPA的区别" class="headerlink" title="一、说一说对SPA的理解? 和MPA的区别?"></a>一、说一说对SPA的理解? 和MPA的区别?</h2><h3 id="什么是SPA和MPA"><a href="#什么是SPA和MPA" class="headerlink" title="什么是SPA和MPA"></a>什么是SPA和MPA</h3><p>SPA：SinglePage Web Application，单页面应用，简称spa</p><p>MPA：MultiPage Application，多页面应用，简称mpa</p><h3 id="对SPA的理解"><a href="#对SPA的理解" class="headerlink" title="对SPA的理解"></a>对SPA的理解</h3><p>SPA指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。有着以下优点</p><ul><li>具有桌面应用的即时性、网站的可移植性和可访问性</li><li>用户体验好、快，内容的改变不需要重新加载整个页面</li><li>良好的前后端分离，分工更明确</li></ul><p>有以下缺点：</p><ul><li>不利于搜索引擎的抓取</li><li>首次渲染速度相对较慢</li></ul><h3 id="SPA和MPA的区别"><a href="#SPA和MPA的区别" class="headerlink" title="SPA和MPA的区别"></a>SPA和MPA的区别</h3><table><thead><tr><th>区别</th><th>SPA</th><th>MPA</th></tr></thead><tbody><tr><td>结构</td><td>一个页面+多个模块组件</td><td>很多完整的页面</td></tr><tr><td>用户体验</td><td>页面切换快，体验好；但是首屏加载可能较慢，资源较多时可能需要做一些相关优化</td><td>页面切换慢，网速较慢的时候体验更差</td></tr><tr><td>资源文件</td><td>组件公用资源只需加载一次</td><td>每个页面都要加载公用资源</td></tr><tr><td>适用场景</td><td>对体验度和流畅度要求较高的应用，不利于SEO如（后台管理系统）</td><td>适用于对SEO要求较高的应用，如京东、淘宝等电商平台</td></tr><tr><td>过度动画</td><td>Vue提供了transition的封装组件，很容易实现</td><td>很难实现</td></tr><tr><td>内容更新</td><td>相关组件的切换，局部更新</td><td>整体HTML得切换，请求次数重复</td></tr><tr><td>路由模式</td><td>可以用hash，也可以用history</td><td>普通跳转</td></tr><tr><td>数据传递</td><td>因为单页面，组件之间传递数据用Vuex可以完美解决</td><td>通过cookie，localstorage等缓存方案，Url传参，调接口保存等方式</td></tr><tr><td>相关成本</td><td>前期开发成本较高，后期维护较容易</td><td>前期开发成本较低，后期维护较麻烦</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RBAC权限管理</title>
      <link href="/2023/05/23/RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/05/23/RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是RBAC"><a href="#1-什么是RBAC" class="headerlink" title="1.什么是RBAC"></a>1.什么是RBAC</h2><p>RBAC 是基于角色的访问控制（Role-Based Access Control ）在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。</p><p>简单的说：用户可以有多个角色，角色可以有多个权限。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive</title>
      <link href="/2023/05/10/vue%E4%B8%AD%E7%9A%84keep-alive/"/>
      <url>/2023/05/10/vue%E4%B8%AD%E7%9A%84keep-alive/</url>
      
        <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>keep-alive作为一种vue的内置组件，主要作用是缓存组件状态。当需要组件的切换时，不用重新渲染组件，避免多次渲染，就可以使用keep-alive包裹组件。</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- include` 字符串或者正则表达式，只有名称匹配的组件会被缓存</span><br><span class="line">- `exclude` 字符串或者正则表达式，任何名称匹配的组件都不会被缓存</span><br><span class="line">- `max` 数字，最多可以缓多少组件实例</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keep-alive`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和`transition`相似，`keep-alive`是一个抽象组件：他自身不会渲染一个dom元素，也不会出现在组件的父组件链中。</span><br><span class="line"></span><br><span class="line">当组件在`keep-alive`内被切换，它的`activated`和`deactivated`这两个生命周期钩子函数将会被对应执行。</span><br><span class="line"></span><br><span class="line">主要用于保留组件状态或者避免重新渲染</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态路由和动态路由</title>
      <link href="/2023/05/04/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2023/05/04/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-静态路由（非自适应路由）"><a href="#1-静态路由（非自适应路由）" class="headerlink" title="1.静态路由（非自适应路由）"></a>1.静态路由（非自适应路由）</h2><p>固定路由表  它不会更改路由表  任何人都可以访问路由 </p><p>一般来说，静态路由是由网络管理员逐项加入路由表。优点是由管理员手工配置，配置灵活，节省链路开销缺点是缺乏灵活性，拓扑变更时需要管理员去每台路由上更改设置</p><p>使用场景：网络规模不大，拓扑结构固定的网络中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  &#123; </span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    component: MapContainer </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/404&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;@/views/404&#x27;),</span><br><span class="line">    hidden: true</span><br><span class="line">  &#125;]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>优点：简单、高效、可靠、网络安全、转发效率高</p><p>缺点：不能灵活的适应网络的动态变化</p><h2 id="动态路由（自适应路由）"><a href="#动态路由（自适应路由）" class="headerlink" title="动态路由（自适应路由）"></a>动态路由（自适应路由）</h2><p>路由不固定 有访问权限才可以访问</p><p>一般来说，动态路由是指路由器能够自动地建立自己的路由表，并且能够根据实际情况的变化适时地进行调整</p><p>使用场景：网络规模大，网络拓扑机构复杂的网络</p><p>优点：灵活，能够适时适应网络结构的变化，无需管理员手工维护，减轻了管理员的工作负担</p><p>缺点：占用网络带宽（用于传输路由更新信息）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 常用的请求方式</title>
      <link href="/2023/04/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/04/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="1-http请求方法有哪些？"><a href="#1-http请求方法有哪些？" class="headerlink" title="1) http请求方法有哪些？"></a>1) http请求方法有哪些？</h4><p>1.POST  向服务器新增数据 </p><p>2.GET 从服务器获取数据 </p><p>3.DELETE 删除服务器上的数据 </p><p>4.PUT 更新服务器上的数据（侧重于完整更新：例如更新用户的完整信息） </p><p>5.PATCH 更新服务器上的数据（侧重于部分更新：例如只更新用户的手机号</p><h4 id="2-常用的http请求方式有哪些？有什么区别？"><a href="#2-常用的http请求方式有哪些？有什么区别？" class="headerlink" title="(2)常用的http请求方式有哪些？有什么区别？"></a>(2)常用的http请求方式有哪些？有什么区别？</h4><p>get和post</p><p>vue中，get发送请求示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>安装 $ npm install axios</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>导入 <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>使用 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 向给定ID的用户发起请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line"><span class="comment">// 处理成功情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>vue中，post发送请示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&#x27;/user&#x27;, &#123;</span><br><span class="line">firstName: &#x27;Fred&#x27;,</span><br><span class="line">lastName: &#x27;Flintstone&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>区别</p><table><thead><tr><th></th><th>GET方法</th><th>POST方法</th></tr></thead><tbody><tr><td><strong>数据传输⽅式</strong></td><td>通过URL传输数据 (地址栏拼接参数)</td><td>通过请求体传输</td></tr><tr><td><strong>数据安全</strong></td><td>数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息</td><td>数据因为在请求主体内， 所以有⼀定的安全性保证</td></tr><tr><td><strong>数据类型</strong></td><td>只允许 ASCII 字符</td><td>⽆限制</td></tr><tr><td><strong>GET⽆害</strong></td><td>刷新、后退等浏览器操作是⽆害的</td><td>可能会引起重复提交表单</td></tr><tr><td><strong>功能特性</strong></td><td>安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。 <strong>幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）</strong></td><td>⾮安全(会引起服务器端的变化)、<strong>⾮幂等</strong></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是vuex</title>
      <link href="/2023/03/23/%E4%BB%80%E4%B9%88%E6%98%AFvuex/"/>
      <url>/2023/03/23/%E4%BB%80%E4%B9%88%E6%98%AFvuex/</url>
      
        <content type="html"><![CDATA[<h2 id="1、什么是vuex-如何使用vuex"><a href="#1、什么是vuex-如何使用vuex" class="headerlink" title="1、什么是vuex? 如何使用vuex?"></a>1、什么是vuex? 如何使用vuex?</h2><p>Vuex是一个集中状态管理模式。一般储存各个组件之间的公用数据</p><p>state:是存储的基本数据。<br>mutations:提交更改数据。<br>getter: 对state加工，和computed计算属性一样。<br>actions：处理异步，通过store.commit方法触发mutations中的方法，从而改变state值。<br>module： 是store分割的模块，每个模块拥有自己的state、mutations、getters、actions。</p><ul><li>通过dispatch去提交一个actions</li><li>actions接收到这个事件之后，在actions中可以执行一些异步|同步操作，根据不同的情况去分发给不同的mutations</li><li>actions通过commit去触发mutations</li><li>mutations去更新state数据，state更新之后，就会通知vue进行渲染</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;button @click=&quot;increment&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">        &#123;&#123;this.$store.getters.getCount&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">            //第一步:this.$store.dispatch(&quot;increment&quot;)触发actions函数&quot;increment&quot;</span><br><span class="line">            this.$store.dispatch(&quot;increment&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">const</span> store =  <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    </span><br><span class="line"><span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：改变state值，state的值只能通过mutations来修改</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：this.$store.commit(&quot;increment&quot;)触发mutations中函数&quot;increment&quot;</span></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">&#123;commit&#125;</span>) &#123;</span><br><span class="line">         <span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>); <span class="comment">//this.$store.commit(&quot;increment&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步：通过getter中的方法来获取state值</span></span><br><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">getCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h2 id="2，页面中如何调用vuex中的方法"><a href="#2，页面中如何调用vuex中的方法" class="headerlink" title="2，页面中如何调用vuex中的方法?"></a>2，页面中如何调用vuex中的方法?</h2><ul><li><strong>state</strong><ul><li>this.$store.state.模块名.属性</li><li>mapState(模块名,[‘属性”]）</li></ul></li><li><strong>mutations</strong><ul><li>this.$store.commit(“模块名&#x2F;属性，×xx）</li><li>mapMutations(模块名&#x2F;方法名,’属性]</li></ul></li><li><strong>actions</strong><ul><li>this.$store.dispatch(‘模块名&#x2F;方法名，xxx)</li><li>mapActions(模块名,[‘属性”]）</li></ul></li><li><strong>getters</strong><ul><li>this.$store.getters[模块名&#x2F;属性]</li><li>mapGetters(模块名,[‘属性”]</li></ul></li></ul><h2 id="3，子模块中为什么要加namespaced"><a href="#3，子模块中为什么要加namespaced" class="headerlink" title="3，子模块中为什么要加namespaced?"></a>3，子模块中为什么要加namespaced?</h2><p>为了让代码更方便维护，让Vuex中不同业务类型涉及到的数据进行分类，同时可以避免不同业务数据分类间的命名冲突问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue自定义指令</title>
      <link href="/2023/03/12/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/03/12/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是Vue指令"><a href="#1-什么是Vue指令" class="headerlink" title="1.什么是Vue指令"></a>1.什么是Vue指令</h2><p><strong>vue指令</strong>： 在 vue 中提供了些对页面和数据更方便的输出方式，实质上就是特殊的 html 标签属性，指令中封装了一些DOM行为 ；特点: v- 开头 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//v-for:可以遍历数组、对象、数字、字符串（可遍历结构）</span><br><span class="line">&lt;div v-for=&quot;(元素值, 下标) in list&quot;:key=&quot;index&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//v-if:v-if控制一个元素的显示隐藏 隐藏时不为display none 而是直接删除</span><br><span class="line">&lt;p v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//v-else:当v-if判断为false时,v-else才执行。</span><br><span class="line">&lt;p v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//v-show:控制一个元素的显示隐藏 隐藏时为display none</span><br><span class="line">&lt;p v-show=&quot;score&gt;=90&quot;&gt;优秀&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//v-bind:单向绑定，用来绑定数据和属性以及表达式，数据只能从data流向页面。</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//v-model:双向绑定，数据能从data流向页面，也能从页面流向data，本质是一种语法糖写法</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&#x27;name&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>自定义指令</strong>：除了核心功能默认内置的指令 ，Vue 也允许注册自定义指令,对普通 DOM元素进行底层操作； 自定义指令分为全局自定义指令和局部自定义指令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//自定义指令钩子函数：</span><br><span class="line">bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line"></span><br><span class="line">inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line"></span><br><span class="line">update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</span><br><span class="line"></span><br><span class="line">componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class="line"></span><br><span class="line">unbind：只调用一次，指令与元素解绑时调用。</span><br><span class="line"></span><br><span class="line">1.全局自定义指令</span><br><span class="line">通过Vue.directive(id,definition)方法可以注册一个全局自定义指令，该方法可以接收两个参数：指令ID和定义对象。指令ID是指令的唯一标识，定义对象是定义的指令的钩子函数</span><br><span class="line"></span><br><span class="line">  Vue.directive(&#x27;自定义事件名&#x27;,&#123;</span><br><span class="line">        //当被绑定的元素插入DOM中时执行</span><br><span class="line">        inserted:function(el)&#123;</span><br><span class="line">            //使元素自动获得焦点</span><br><span class="line">            el.focus();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> 2.注册局部自定义指令</span><br><span class="line"> </span><br><span class="line"> var demo = new Vue(&#123;</span><br><span class="line">         el: &#x27;#element&#x27;,</span><br><span class="line">         directives:&#123;</span><br><span class="line">            addBorder:&#123;</span><br><span class="line">             //当被绑定的元素插入DOM中时执行</span><br><span class="line">                inserted:function(el,binding)&#123;</span><br><span class="line">                  //使元素自动获得焦点</span><br><span class="line">                   el.focus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手</title>
      <link href="/2022/12/23/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2022/12/23/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="1）三次握手"><a href="#1）三次握手" class="headerlink" title="1）三次握手"></a>1）三次握手</h5><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li></ul><blockquote><p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote><ul><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li></ul><blockquote><p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y</p></blockquote><ul><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li></ul><blockquote><p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></blockquote><p><strong>那为什么要三次握手呢？两次不行吗？</strong></p><ul><li>为了确认双方的接收能力和发送能力都正常</li><li>如果是用两次握手，则会出现下面这种情况：</li></ul><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><p><strong>简单来说就是以下三步：</strong></p><ul><li><strong>第一次握手：</strong>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li><li><strong>第二次握手：</strong>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li><li><strong>第三次握手：</strong>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li></ul><p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><h5 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h5><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li></ul><blockquote><p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p></blockquote><ul><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li></ul><blockquote><p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p></blockquote><ul><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li></ul><blockquote><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p></blockquote><ul><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><blockquote><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p></blockquote><p><strong>那为什么需要四次挥手呢？</strong></p><blockquote><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p></blockquote><p><strong>简单来说就是以下四步：</strong></p><ul><li><strong>第一次<strong><strong>挥手</strong></strong>：</strong>若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li><li><strong>第二次****挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li><li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li><li><strong>第四次<strong><strong>挥手</strong></strong>：</strong>客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li></ul><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
